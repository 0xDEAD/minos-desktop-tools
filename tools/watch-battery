#!/bin/sh
#description: display a warning when the system is running out of energy
#             suspend|hibernate if no manual action is taken
#usage: watch-battery

#it indend to be used as a cron job
#eg, (every 3 min)
#*/3 * * * * /path/to/this/script

PATH=/bin:/usr/bin:/sbin:/usr/sbin

_basename()
{
    [ -z "${1}" ] && return 1 || _basename__name="${1}"
    [ -z "${2}" ] || _basename__suffix="${2}"
    case "${_basename__name}" in
        /*|*/*) _basename__name="$(expr "${_basename__name}" : '.*/\([^/]*\)')" ;;
    esac

    if [ -n "${_basename__suffix}" ] && [ "${#_basename__name}" -gt "${#2}" ]; then
        if [ X"$(printf "%s" "${_basename__name}" | cut -c"$((${#_basename__name} - ${#_basename__suffix} + 1))"-"${#_basename__name}")" \
           = X"$(printf "%s" "${_basename__suffix}")" ]; then
            _basename__name="$(printf "%s" "${_basename__name}" | cut -c1-"$((${#_basename__name} - ${#_basename__suffix}))")"
        fi
    fi

    printf "%s\\n" "${_basename__name}"
}

_usage()
{
    printf "%s\\n" "Usage: $(_basename "${0}")" >&2
    printf "%s\\n" "This program should be run as a cron job, eg.: */3 * * * * $(_basename "${0}")" >&2
    exit 1
}

_notify()
{
    [ -z "${1}" ] && return 1

    if [ X"${TERM}" = X"linux" ] || [ -z "${TERM}" ]; then
        kill -9 $(pgrep notify-osd) >/dev/null 2>&1
        if [ X"${LOGNAME}" = X"root" ]; then
            #hack to allow notifications from cronjobs
            _notify__pid=$(pgrep dbus-launch|head -1)
            _notify__user=$(grep -z USER /proc/"${_notify__pid}"/environ | sed 's/USER=//')
            _notify__dbus="$(awk \
                '/^DBUS_SESSION_BUS_ADDRESS/ {sub(/DBUS_SESSION_BUS_ADDRESS=/,""); print $0; exit}' \
                /home/"${_notify__user}"/.dbus/session-bus/$(dbus-uuidgen --get)-*)"
            _notify__display=$(grep -z DISPLAY /proc/"${_notify__pid}"/environ | sed 's/DISPLAY=//')

            if ! sudo -u "${_notify__user}" sh -c \
                "DBUS_SESSION_BUS_ADDRESS=\"${_notify__dbus}\" DISPLAY=\"${_notify__display}\" notify-send -t 1000 \"${1}\"  \"${2}\""; then
                if command -v "gxmessage" 2>/dev/null; then
                    _notify__font="Monaco 9"
                    gxmessage "${_notify__font:+-fn "$_notify__font"}" "${1} ${2}" "ok"
                else
                    _notify__font="fixed"
                    xmessage "${_notify__font:+-fn "$_notify__font"}" "${1} ${2}" "ok"
                fi
            fi
        else
            if ! DISPLAY=:0 notify-send -t 1000 "${1}"  "${2}"; then
                if command -v "gxmessage" 2>/dev/null; then
                    _notify__font="Monaco 9"
                    gxmessage "${_notify__font:+-fn "$_notify__font"}" "${1} ${2}" "ok"
                else
                    _notify__font="fixed"
                    xmessage "${_notify__font:+-fn "$_notify__font"}" "${1} ${2}" "ok"
                fi
            fi
        fi
    else
        if [ -z "${2}" ]; then
            printf "%s\\n" "${1}"
        else
            printf "%s: %s\\n" "${1}" "${2}"
        fi
    fi
}

_valid_batt_values()
{
    if [ -z "${1}" ]; then
        return 1
    else
        _vbv__result="$(printf "%s" "${1}" | awk '{ gsub(/^[ \t]+|[ \t]+$/, ""); print }')"
        while [ "${_vbv__result}" ]; do
            _vbv__option="${_vbv__result%%,*}"
            if ! printf "%s" "${_vbv__option}" | grep -v "[^0-9]" >/dev/null; then
                return 1
            fi
            [ X"${_vbv__result}" = X"${_vbv__option}" ] && _vbv__result='' \
                || _vbv__result="${_vbv__result#*,}"
        done
        printf "%s" "${1}"
    fi
}

_sort_batt_values()
{ if [ -z "${1}" ]; then
        return 1
    else
        _sbv__result="$(printf "%s" "${1}" | awk '{ gsub(/^[ \t]+|[ \t]+$/, ""); print }')"
        _sbv__result="$(printf "%s" "${_sbv__result}" | tr "," "\n" | sort -n |tr "\n" ",")"
        printf "%s" "${_sbv__result%,}"
    fi
}

for arg in "${@}"; do #parse options
    case "${arg}" in
        --) shift; break  ;;
        -h|--help) _usage ;;
        -*) printf "%s\\n" "$(expr "${0}" : '.*/\([^/]*\)'): unrecognized option \`${arg}'" >&2; _usage ;;
    esac
done

[ X"${LOGNAME}" = X"root" ] && user=$(grep 1000 /etc/group | cut -d: -f1) || user="${LOGNAME}"
bin="$(HOME=/home/$user minos-config m-battery 2>/dev/null)"
case "${bin}" in
      no|NO|No|nO) return        ;;
    watch-battery) :             ;;
                *) exec "${bin}" ;;
esac

progname="$(_basename "${0}")"
exec 9>/tmp/"${progname}".lock
[ X"${LOGNAME}" = X"root" ] && chmod 666 /tmp/"${progname}".lock
if ! flock -n 9 ; then
    _notify "${progname}: another instance is running";
    exit 1
fi

if [ ! -f "$(command -v notify-send)" ] || [ ! -f "$(command -v pm-hibernate)" ] || [ ! -f "$(command -v acpi)" ]; then
    _notify  "Error" "you need to install 'acpi', 'notify-send' and 'pm-utils' to run this program"
    exit 1
fi

#=====VARS=====
#current battery status (Charging/Discharging/AC/Unknown)
stat="$(acpi -b | awk '{sub(",", ""); print $3}')"
#battery percentage
batt_current="$(acpi -b |awk '{if ($0 ~ "%,") sub("%,", ""); else sub("%", ""); print $4}')"
batt_last_seen="$(cat /tmp/"${progname}" 2>/dev/null)"
action="$(HOME=/home/$user minos-config m-hibernate 2>/dev/null)"
[ -z "${action}" ] && action="$(command -v pm-hibernate)"
batt_at="$(HOME=/home/$user minos-config watch-battery-config 2>/dev/null)"
[ -z "$(_valid_batt_values "${batt_at}")" ] && batt_at="15,10,7,5"
batt_at="$(_sort_batt_values "${batt_at}")"
#=============

if command -v "gksudo" >/dev/null 2>&1; then
    _sudo="gksudo"
else
    _sudo="sudo"
fi

if [ X"${stat}" = X"Discharging" ]; then
    batt_values_buf="${batt_at}"; i="0"
    while [ "${batt_values_buf}" ]; do
        batt_value="${batt_values_buf%%,*}"; i="$((${i}+1))"
        if [ "${batt_current}" -lt "${batt_value}" ]; then
            case "${i}" in
                1)  # Battery in the latest valid value -> force to take action
                    _notify "Critical" "battery under ${batt_value}%, the system will hibernate in 30 seconds, unless you plugin the computer"
                    j=0 ; while [ "${j}" -lt "30" ]; do
                        sleep 1
                        stat="$(acpi -b | awk '{sub(",", ""); print $3}')"
                        if [ X"${stat}" != X"Discharging" ]; then
                            _notify  "Charging" "charging now..."
                            break
                        fi
                        j="$((${j} + 1))"
                    done

                    #check for the last time if someone has pluged in the machine
                    stat="$(acpi -b | awk '{sub(",", ""); print $3}')"

                    if [ X"${stat}" = X"Discharging" ]; then
                        [ -x "$(command -v mpc)" ] && mpc stop
                        if [ X"${LOGNAME}" = X"root" ]; then
                            HOME=/home/$user USER=$user DISPLAY=:0 ${action}
                        else
                            ${_sudo} ${action}
                        fi
                    fi
                    ;;
                *)
                    [ X"${batt_last_seen}" = X"${batt_value}" ] && exit 0
                    _notify  "Warning" "battery under ${batt_value}%"
                    batt_last_seen="${batt_value}"
                    ;;
            esac
            printf "%s\\n" "${batt_last_seen}" > /tmp/"${progname}"
            [ X"${LOGNAME}" = X"root" ] && chmod 666 /tmp/"${progname}" || :
            break
        fi
        [ X"${batt_values_buf}" = X"${batt_value}" ] && batt_values_buf='' || batt_values_buf="${batt_values_buf#*,}"
    done
fi
